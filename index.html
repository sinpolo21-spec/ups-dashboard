<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise UPS Management System - Advanced Analytics Platform</title>
    
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #ecf0f1;
            --text-secondary: #bdc3c7;
            --accent-blue: #5dade2;
            --accent-green: #58d68d;
            --accent-purple: #bb8fce;
            --accent-orange: #f7dc6f;
            --danger: #ec7063;
            --warning: #f39c12;
            --success: #27ae60;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: radial-gradient(ellipse at top, #1a1a2e, #16213e), 
                        linear-gradient(135deg, #0f0f23, #1a1a2e);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
            font-weight: 400;
            line-height: 1.6;
        }

        /* Loading System */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20000;
        }

        .loading-logo {
            width: 120px;
            height: 120px;
            border: 4px solid transparent;
            border-top: 4px solid #667eea;
            border-right: 4px solid #764ba2;
            border-bottom: 4px solid #f093fb;
            border-radius: 50%;
            animation: complexSpin 2s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes complexSpin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .loading-text {
            color: var(--accent-blue);
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }

        .loading-progress {
            width: 300px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .loading-progress-bar {
            width: 0%;
            height: 100%;
            background: var(--primary-gradient);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .loading-status {
            color: var(--text-secondary);
            font-size: 14px;
            text-align: center;
        }

        /* Login Portal */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95), rgba(26, 26, 46, 0.95));
            backdrop-filter: blur(20px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .login-container {
            background: var(--glass-bg);
            backdrop-filter: blur(25px);
            border: 2px solid var(--glass-border);
            border-radius: 28px;
            padding: 60px;
            text-align: center;
            box-shadow: 0 30px 80px rgba(0,0,0,0.6);
            min-width: 520px;
            animation: loginGlide 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }

        @keyframes loginGlide {
            from { opacity: 0; transform: translateY(-60px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .login-title {
            font-size: 3.2rem;
            margin-bottom: 20px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 800;
            letter-spacing: -2px;
        }

        .login-subtitle {
            color: var(--text-secondary);
            margin-bottom: 40px;
            font-size: 1.3rem;
            font-weight: 300;
        }

        .login-input {
            width: 100%;
            padding: 22px 28px;
            margin-bottom: 28px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 18px;
            background: rgba(255,255,255,0.05);
            color: var(--text-primary);
            font-size: 17px;
            backdrop-filter: blur(10px);
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            font-weight: 500;
        }

        .login-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 40px rgba(102, 126, 234, 0.5);
            transform: scale(1.02);
            background: rgba(255,255,255,0.1);
        }

        .login-btn {
            width: 100%;
            padding: 22px;
            border: none;
            border-radius: 18px;
            background: var(--primary-gradient);
            color: white;
            font-size: 19px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .login-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 60px rgba(102, 126, 234, 0.6);
        }

        .security-notice {
            margin-top: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .login-error {
            color: var(--danger);
            margin-top: 15px;
            font-weight: 600;
        }

        /* Header */
        .header {
            background: var(--primary-gradient);
            color: white;
            padding: 50px 30px;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shimmer 4s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .header h1 {
            font-size: 4rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 12px rgba(0,0,0,0.4);
            font-weight: 900;
            letter-spacing: -3px;
        }

        .header p {
            font-size: 1.5rem;
            opacity: 0.95;
            font-weight: 300;
            letter-spacing: 1px;
        }

        /* Container */
        .container {
            max-width: 2000px;
            margin: 0 auto;
            padding: 40px;
        }

        /* Grid System */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 40px;
            margin-bottom: 40px;
        }

        .main-panel, .side-panel {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }

        /* Panel System */
        .panel {
            background: var(--glass-bg);
            backdrop-filter: blur(25px);
            border: 2px solid var(--glass-border);
            border-radius: 28px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            border-radius: 28px 28px 0 0;
        }

        .panel:hover {
            transform: translateY(-8px);
            box-shadow: 0 30px 80px rgba(0,0,0,0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Control Panel */
        .control-panel {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(46, 204, 113, 0.1));
            border-color: rgba(39, 174, 96, 0.3);
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin-bottom: 35px;
        }

        .btn {
            padding: 20px 35px;
            border: none;
            border-radius: 18px;
            cursor: pointer;
            font-weight: 700;
            font-size: 16px;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-6px);
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
        }

        .btn-start { 
            background: linear-gradient(135deg, #27ae60, #2ecc71, #58d68d); 
            color: white;
        }
        .btn-stop { 
            background: linear-gradient(135deg, #e74c3c, #c0392b, #ec7063); 
            color: white;
        }
        .btn-export { 
            background: linear-gradient(135deg, #3498db, #2980b9, #5dade2); 
            color: white;
        }
        .btn-ai { 
            background: linear-gradient(135deg, #9b59b6, #8e44ad, #bb8fce); 
            color: white;
        }
        .btn-simulate { 
            background: linear-gradient(135deg, #f39c12, #e67e22, #f7dc6f); 
            color: white;
        }
        .btn-analyze { 
            background: linear-gradient(135deg, #16a085, #1abc9c, #7fb3d3); 
            color: white;
        }

        /* Status System */
        .status {
            font-size: 24px;
            font-weight: 700;
            color: var(--success);
            display: flex;
            align-items: center;
            gap: 25px;
            padding: 30px;
            background: rgba(39, 174, 96, 0.15);
            border-radius: 18px;
            border-left: 6px solid var(--success);
            box-shadow: 0 10px 30px rgba(39, 174, 96, 0.2);
        }

        .status-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--success);
            animation: advancedPulse 2s infinite;
            box-shadow: 0 0 25px var(--success);
        }

        @keyframes advancedPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.3); box-shadow: 0 0 40px var(--success); }
        }

        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .metric-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 24px;
            padding: 35px;
            text-align: center;
            transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: var(--primary-gradient);
            background-size: 400% 100%;
            animation: gradientFlow 5s ease infinite;
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .metric-card:hover {
            transform: translateY(-12px) scale(1.05);
            box-shadow: 0 25px 60px rgba(0,0,0,0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .metric-title {
            font-size: 15px;
            color: var(--text-secondary);
            margin-bottom: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
        }

        .metric-value {
            font-size: 3.5rem;
            font-weight: 900;
            margin-bottom: 12px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.1;
        }

        .metric-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
            opacity: 0.8;
        }

        /* Charts Container */
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-bottom: 40px;
        }

        .chart-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(25px);
            border: 2px solid var(--glass-border);
            border-radius: 28px;
            padding: 35px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .chart-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
        }

        .chart-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 12px;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }

        .chart-subtitle {
            font-size: 15px;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-weight: 500;
        }

        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(26,26,46,0.9));
            border-radius: 16px;
            padding: 20px;
            border: 2px solid rgba(255,255,255,0.1);
        }

        /* 3D Container */
        .topology-3d {
            height: 450px;
            background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.3));
            border-radius: 24px;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--glass-border);
            box-shadow: inset 0 4px 25px rgba(0,0,0,0.5);
        }

        /* AI Panel */
        .ai-panel {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.25), rgba(142, 68, 173, 0.15));
            border: 2px solid rgba(155, 89, 182, 0.4);
        }

        .ai-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 30px;
            color: var(--accent-purple);
            letter-spacing: 0.5px;
        }

        .ai-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }

        .ai-metric {
            background: rgba(155, 89, 182, 0.2);
            padding: 25px;
            border-radius: 18px;
            text-align: center;
            border: 2px solid rgba(155, 89, 182, 0.4);
            transition: all 0.3s ease;
        }

        .ai-metric:hover {
            transform: scale(1.05);
            border-color: rgba(155, 89, 182, 0.6);
        }

        .ai-metric-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ai-metric-value {
            font-size: 22px;
            font-weight: 800;
            color: var(--accent-purple);
        }

        /* Financial Panel */
        .financial-panel {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(46, 204, 113, 0.1));
            border: 2px solid rgba(39, 174, 96, 0.4);
        }

        .financial-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 15px;
            line-height: 1.6;
        }

        .financial-item:last-child {
            border-bottom: none;
        }

        .financial-label {
            color: var(--text-secondary);
            font-weight: 600;
        }

        .financial-value {
            font-weight: 700;
            font-size: 16px;
        }

        .financial-value.cost { color: var(--accent-blue); }
        .financial-value.savings { color: var(--accent-green); }
        .financial-value.roi { color: var(--accent-orange); }

        /* Notification System */
        .notification {
            position: fixed;
            top: 40px;
            right: 40px;
            background: linear-gradient(135deg, var(--success), #2ecc71);
            color: white;
            padding: 25px 35px;
            border-radius: 18px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
            z-index: 1000;
            max-width: 450px;
            animation: slideInRight 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            border-left: 6px solid #ffffff;
            font-weight: 600;
        }

        .notification.error { background: linear-gradient(135deg, var(--danger), #c0392b); }
        .notification.info { background: linear-gradient(135deg, var(--accent-blue), #2980b9); }
        .notification.warning { background: linear-gradient(135deg, var(--warning), #e67e22); }

        @keyframes slideInRight {
            from { transform: translateX(120%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 1600px) {
            .dashboard-grid { grid-template-columns: 1fr; }
            .charts-container { grid-template-columns: 1fr; }
        }

        @media (max-width: 768px) {
            .container { padding: 25px; }
            .header h1 { font-size: 2.8rem; }
            .header p { font-size: 1.2rem; }
            .control-buttons { grid-template-columns: 1fr; }
            .metrics-grid { grid-template-columns: 1fr; }
            .ai-metrics { grid-template-columns: 1fr; }
            .login-container { min-width: 340px; margin: 25px; padding: 40px; }
        }

        /* Skip Loading Button */
        .skip-loading {
            position: absolute;
            bottom: 50px;
            right: 50px;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .skip-loading:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Loading Screen with Skip Option -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo"></div>
        <div class="loading-text">Enterprise UPS System</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgress"></div>
        </div>
        <div class="loading-status" id="loadingStatus">Initializing core systems...</div>
        <button class="skip-loading" onclick="skipToLogin()">Skip Loading</button>
    </div>

    <!-- Login Portal -->
    <div class="login-overlay" id="loginOverlay">
        <div class="login-container">
            <h1 class="login-title">Enterprise Portal</h1>
            <p class="login-subtitle">Advanced UPS Management System</p>
            <form id="loginForm">
                <input type="text" class="login-input" id="username" placeholder="Username" required>
                <input type="password" class="login-input" id="password" placeholder="Password" required>
                <button type="submit" class="login-btn">Access Enterprise Dashboard</button>
            </form>
            <div class="login-error" id="loginError"></div>
            <div class="security-notice">
                <strong>Enterprise Security Notice:</strong> This system requires authenticated access to advanced UPS analytics and AI-driven optimization systems.<br>
                <strong>Demo Access:</strong> admin / enterprise2024
            </div>
        </div>
    </div>

    <!-- Main Enterprise Dashboard -->
    <div id="mainDashboard" style="display: none;">
        <div class="header">
            <h1>Enterprise UPS Management System</h1>
            <p>AI-Driven Power Analytics | Predictive Maintenance | Real-time Optimization</p>
        </div>
        
        <div class="container">
            <div class="dashboard-grid">
                <div class="main-panel">
                    <!-- Control Center -->
                    <div class="panel control-panel">
                        <h3 style="font-size: 28px; font-weight: 800; margin-bottom: 30px; color: var(--accent-green);">Mission Control Center</h3>
                        <div class="control-buttons">
                            <button class="btn btn-start" onclick="startSystem()">Start System</button>
                            <button class="btn btn-stop" onclick="stopSystem()">Emergency Stop</button>
                            <button class="btn btn-simulate" onclick="runSimulation()">Run Simulation</button>
                            <button class="btn btn-analyze" onclick="performAnalysis()">Deep Analysis</button>
                            <button class="btn btn-export" onclick="exportReport()">Export Report</button>
                            <button class="btn btn-ai" onclick="toggleAIMode()">AI Optimization</button>
                        </div>
                        <div class="status" id="systemStatus">
                            <div class="status-indicator"></div>
                            SYSTEM STATUS: ACTIVE - Enterprise AI Engine Running
                        </div>
                    </div>
                    
                    <!-- Performance Metrics -->
                    <div class="panel">
                        <h3 style="font-size: 28px; font-weight: 800; margin-bottom: 30px; color: var(--text-primary);">Real-time Performance Analytics</h3>
                        <div class="metrics-grid">
                            <div class="metric-card">
                                <div class="metric-title">Current Load</div>
                                <div class="metric-value" id="currentLoad">32,520 VA</div>
                                <div class="metric-subtitle">Volt-Amperes | Real-time</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">AI Efficiency</div>
                                <div class="metric-value" id="systemEfficiency">87.4%</div>
                                <div class="metric-subtitle">Neural optimization active</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Power Factor</div>
                                <div class="metric-value" id="powerFactor">0.946</div>
                                <div class="metric-subtitle">Leading | Capacitive load</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Frequency</div>
                                <div class="metric-value" id="frequency">49.98 Hz</div>
                                <div class="metric-subtitle">Grid synchronization</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">THD Input</div>
                                <div class="metric-value" id="thdInput">3.24%</div>
                                <div class="metric-subtitle">Total harmonic distortion</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">THD Output</div>
                                <div class="metric-value" id="thdOutput">1.87%</div>
                                <div class="metric-subtitle">Clean power delivery</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Battery Health</div>
                                <div class="metric-value" id="batteryHealth">91.2%</div>
                                <div class="metric-subtitle">Predictive maintenance</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Temperature</div>
                                <div class="metric-value" id="temperature">42.7°C</div>
                                <div class="metric-subtitle">Thermal management</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">DC Bus Voltage</div>
                                <div class="metric-value" id="dcVoltage">384 VDC</div>
                                <div class="metric-subtitle">Nominal: 380V ±5%</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Input Voltage</div>
                                <div class="metric-value" id="inputVoltage">398 VAC</div>
                                <div class="metric-subtitle">L-L RMS | 3-Phase</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Output Voltage</div>
                                <div class="metric-value" id="outputVoltage">400 VAC</div>
                                <div class="metric-subtitle">Regulated ±1%</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Backup Time</div>
                                <div class="metric-value" id="backupTime">47.3 min</div>
                                <div class="metric-subtitle">At current load</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Energy Optimized</div>
                                <div class="metric-value" id="energySaved">234 kWh</div>
                                <div class="metric-subtitle">Total AI optimization gains</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Peak Demand</div>
                                <div class="metric-value" id="peakDemand">67.8 kW</div>
                                <div class="metric-subtitle">Today's maximum</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Cost Reduction</div>
                                <div class="metric-value" id="costSavings">R12,847</div>
                                <div class="metric-subtitle">Financial optimization (ZAR)</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Neural Score</div>
                                <div class="metric-value" id="neuralScore">89.7</div>
                                <div class="metric-subtitle">AI performance index</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">IGBT Temperature</div>
                                <div class="metric-value" id="igbtTemp">67.2°C</div>
                                <div class="metric-subtitle">Switching devices</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Transformer Temp</div>
                                <div class="metric-value" id="transformerTemp">54.8°C</div>
                                <div class="metric-subtitle">Isolation transformer</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Capacitor ESR</div>
                                <div class="metric-value" id="capacitorESR">0.047 Ω</div>
                                <div class="metric-subtitle">DC link capacitor</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Switching Freq</div>
                                <div class="metric-value" id="switchingFreq">16.2 kHz</div>
                                <div class="metric-subtitle">PWM modulation</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Dead Time</div>
                                <div class="metric-value" id="deadTime">2.8 μs</div>
                                <div class="metric-subtitle">IGBT protection</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Ripple Current</div>
                                <div class="metric-value" id="rippleCurrent">4.7 Arms</div>
                                <div class="metric-subtitle">Capacitor stress</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">dV/dt Rate</div>
                                <div class="metric-value" id="dvdtRate">1247 V/μs</div>
                                <div class="metric-subtitle">Switching transients</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-title">Fault Count</div>
                                <div class="metric-value" id="faultCount">0</div>
                                <div class="metric-subtitle">24h period</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Charts Container -->
                    <div class="charts-container">
                        <div class="chart-panel">
                            <div class="chart-title">LSTM Neural Network Predictions</div>
                            <div class="chart-subtitle">Deep Learning Load Forecasting with Confidence Intervals</div>
                            <div class="chart-container">
                                <canvas id="loadChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-panel">
                            <div class="chart-title">PSO Efficiency Optimization</div>
                            <div class="chart-subtitle">Particle Swarm Optimization Results</div>
                            <div class="chart-container">
                                <canvas id="efficiencyChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Analysis Panel -->
                    <div class="charts-container">
                        <div class="chart-panel">
                            <div class="chart-title">Harmonic Distortion Analysis</div>
                            <div class="chart-subtitle">Real-time THD & Power Quality Assessment</div>
                            <div class="chart-container">
                                <canvas id="harmonicChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-panel">
                            <div class="chart-title">Neural Network Architecture</div>
                            <div class="chart-subtitle">Live AI Model Visualization</div>
                            <div class="chart-container">
                                <canvas id="neuralChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="side-panel">
                    <!-- AI Engine Panel -->
                    <div class="panel ai-panel">
                        <div class="ai-title">Enterprise AI Engine</div>
                        <div class="ai-metrics">
                            <div class="ai-metric">
                                <div class="ai-metric-label">Neural Accuracy</div>
                                <div class="ai-metric-value" id="modelAccuracy">92.4%</div>
                            </div>
                            <div class="ai-metric">
                                <div class="ai-metric-label">Prediction Confidence</div>
                                <div class="ai-metric-value" id="predictionConfidence">87.8%</div>
                            </div>
                            <div class="ai-metric">
                                <div class="ai-metric-label">Learning Rate</div>
                                <div class="ai-metric-value" id="learningRateDisplay">0.001</div>
                            </div>
                            <div class="ai-metric">
                                <div class="ai-metric-label">Training Samples</div>
                                <div class="ai-metric-value" id="trainingSamples">1.2M</div>
                            </div>
                            <div class="ai-metric">
                                <div class="ai-metric-label">Model Layers</div>
                                <div class="ai-metric-value" id="modelLayers">24</div>
                            </div>
                            <div class="ai-metric">
                                <div class="ai-metric-label">Processing Speed</div>
                                <div class="ai-metric-value" id="processingSpeed">543 Hz</div>
                            </div>
                        </div>
                        <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px; line-height: 1.8;">
                            <strong>Active Neural Networks:</strong><br>
                            LSTM Deep Learning | Transformer Architecture<br>
                            PSO Multi-Objective | Genetic Algorithm<br>
                            Fuzzy Logic Control | Reinforcement Learning<br>
                            Anomaly Detection | Pattern Recognition
                        </div>
                    </div>
                    
                    <!-- Financial Analysis -->
                    <div class="panel financial-panel">
                        <h3 style="font-size: 24px; font-weight: 800; margin-bottom: 25px; color: var(--accent-green);">Enterprise Financial Analysis</h3>
                        <div class="financial-item">
                            <span class="financial-label">Daily Energy Cost:</span>
                            <span class="financial-value cost" id="dailyCost">R1,847.36</span>
                        </div>
                        <div class="financial-item">
                            <span class="financial-label">Monthly Estimate:</span>
                            <span class="financial-value cost" id="monthlyCost">R55,420.80</span>
                        </div>
                        <div class="financial-item">
                            <span class="financial-label">Annual Projection:</span>
                            <span class="financial-value cost" id="annualCost">R673,286.40</span>
                        </div>
                        <div class="financial-item">
                            <span class="financial-label">AI Optimization Savings:</span>
                            <span class="financial-value savings" id="potentialSavings">R89,471.55</span>
                        </div>
                        <div class="financial-item">
                            <span class="financial-label">ROI Achievement:</span>
                            <span class="financial-value roi" id="roiPeriod">2.3 years</span>
                        </div>
                        <div class="financial-item">
                            <span class="financial-label">Carbon Footprint:</span>
                            <span class="financial-value" id="carbonFootprint" style="color: #58d68d;">524.7 kg CO₂</span>
                        </div>
                    </div>
                    
                    <!-- 3D System Topology -->
                    <div class="panel">
                        <h4 style="font-size: 22px; font-weight: 700; margin-bottom: 20px; color: var(--text-primary);">3D Enterprise Topology</h4>
                        <div class="topology-3d" id="topology3d"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load external libraries asynchronously -->
    <script>
        // Global Configuration with Realistic Values
        const ENTERPRISE_CONFIG = {
            electricityRate: 2.47,
            systemRunning: false,
            aiMode: false,
            charts: {},
            timeSeriesData: {
                timestamps: [],
                loadData: [],
                efficiencyData: [],
                harmonicData: []
            },
            currentTime: 0,
            totalRuntime: 0,
            librariesLoaded: {
                three: false,
                chart: false
            },
            currentMetrics: {}
        };

        // Enhanced Error Handling
        function safeExecute(fn, fallback = null) {
            try {
                return fn();
            } catch (error) {
                console.warn('Function execution failed:', error);
                return fallback;
            }
        }

        // Skip loading function
        function skipToLogin() {
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('loginOverlay').style.display = 'flex';
            generateRealisticData();
        }

        // Robust Loading System with Timeout
        function initializeSystem() {
            const loadingSteps = [
                { text: 'Initializing core systems...', duration: 300 },
                { text: 'Loading neural networks...', duration: 400 },
                { text: 'Configuring optimization...', duration: 350 },
                { text: 'Establishing connections...', duration: 400 },
                { text: 'Calibrating sensors...', duration: 250 },
                { text: 'Activating AI modules...', duration: 500 },
                { text: 'System ready...', duration: 200 }
            ];

            let currentStep = 0;
            const progressBar = document.getElementById('loadingProgress');
            const statusText = document.getElementById('loadingStatus');

            function executeStep() {
                if (currentStep < loadingSteps.length) {
                    const step = loadingSteps[currentStep];
                    statusText.textContent = step.text;
                    progressBar.style.width = `${((currentStep + 1) / loadingSteps.length) * 100}%`;
                    
                    setTimeout(() => {
                        currentStep++;
                        executeStep();
                    }, step.duration);
                } else {
                    // Loading complete
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        document.getElementById('loginOverlay').style.display = 'flex';
                        generateRealisticData();
                        loadExternalLibraries();
                    }, 500);
                }
            }

            executeStep();
            
            // Safety timeout to prevent infinite loading
            setTimeout(() => {
                if (document.getElementById('loadingScreen').style.display !== 'none') {
                    skipToLogin();
                }
            }, 5000);
        }

        // Load external libraries after main interface is ready
        function loadExternalLibraries() {
            // Load Chart.js
            const chartScript = document.createElement('script');
            chartScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js';
            chartScript.onload = () => {
                ENTERPRISE_CONFIG.librariesLoaded.chart = true;
                console.log('Chart.js loaded successfully');
            };
            chartScript.onerror = () => {
                console.warn('Chart.js failed to load - using canvas fallback');
                ENTERPRISE_CONFIG.librariesLoaded.chart = false;
            };
            document.head.appendChild(chartScript);

            // Load Three.js
            const threeScript = document.createElement('script');
            threeScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            threeScript.onload = () => {
                ENTERPRISE_CONFIG.librariesLoaded.three = true;
                console.log('Three.js loaded successfully');
            };
            threeScript.onerror = () => {
                console.warn('Three.js failed to load - using 2D fallback');
                ENTERPRISE_CONFIG.librariesLoaded.three = false;
            };
            document.head.appendChild(threeScript);
        }

        // Initialize on DOM load
        document.addEventListener('DOMContentLoaded', function() {
            initializeSystem();
            
            const loginForm = document.getElementById('loginForm');
            if (loginForm) {
                loginForm.addEventListener('submit', function(event) {
                    event.preventDefault();
                    
                    const username = document.getElementById('username').value.trim();
                    const password = document.getElementById('password').value.trim();
                    
                    if (username === 'admin' && password === 'enterprise2024') {
                        document.getElementById('loginOverlay').style.display = 'none';
                        document.getElementById('mainDashboard').style.display = 'block';
                        showNotification('Enterprise System Activated - Welcome Administrator', 'success');
                        initializeDashboard();
                    } else {
                        document.getElementById('loginError').textContent = 'Access Denied - Invalid Enterprise Credentials';
                        showNotification('Authentication Failed - Security Protocol Activated', 'error');
                    }
                });
            }
        });

        // Generate Realistic Data
        function generateRealisticData() {
            const now = Date.now();
            for (let i = 60; i >= 0; i--) {
                const timestamp = new Date(now - i * 60000);
                const hours = timestamp.getHours();
                
                // Realistic load patterns
                const baseLoad = 32000;
                const timeVariation = Math.sin((hours / 24) * 2 * Math.PI) * baseLoad * 0.25;
                const businessHours = (hours >= 8 && hours <= 18) ? 1.2 : 0.8;
                const randomVariation = (Math.random() - 0.5) * baseLoad * 0.12;
                const load = Math.max(18000, baseLoad * businessHours + timeVariation + randomVariation);
                
                // Realistic efficiency (80-95% range)
                const baseEfficiency = 85 + (Math.random() * 8);
                const loadEffect = (load / baseLoad - 1) * -3;
                const efficiency = Math.max(78, Math.min(94, baseEfficiency + loadEffect));
                
                // Harmonic distortion
                const harmonic = 3.2 + Math.sin(i * 0.1) * 1.2 + Math.random() * 1.5;
                
                ENTERPRISE_CONFIG.timeSeriesData.timestamps.push(timestamp);
                ENTERPRISE_CONFIG.timeSeriesData.loadData.push(load);
                ENTERPRISE_CONFIG.timeSeriesData.efficiencyData.push(efficiency);
                ENTERPRISE_CONFIG.timeSeriesData.harmonicData.push(harmonic);
            }
        }

        // Initialize Dashboard with Enhanced Error Handling
        function initializeDashboard() {
            console.log('Initializing enterprise dashboard with enhanced systems...');
            
            // Ensure DOM is fully ready
            if (document.readyState !== 'complete') {
                window.addEventListener('load', initializeDashboard);
                return;
            }
            
            // Initialize charts with delay to ensure container sizing
            setTimeout(() => {
                safeExecute(() => {
                    initializeCanvasCharts();
                    console.log('✓ Canvas charts initialized');
                });
            }, 500);
            
            // Initialize neural network chart
            setTimeout(() => {
                safeExecute(() => {
                    initializeNeuralChart();
                    console.log('✓ Neural network chart initialized');
                });
            }, 700);

            // Initialize 3D topology with enhanced visuals
            setTimeout(() => {
                safeExecute(() => {
                    initialize3DTopology();
                    console.log('✓ 3D topology initialized');
                });
            }, 1000);

            // Start real-time simulation
            setTimeout(() => {
                safeExecute(() => {
                    startRealTimeSimulation();
                    console.log('✓ Real-time simulation started');
                });
            }, 1500);

            // Add resize handler for responsive behavior
            window.addEventListener('resize', debounce(() => {
                safeExecute(() => {
                    // Reinitialize charts on significant resize
                    ['loadChart', 'efficiencyChart', 'harmonicChart', 'neuralChart'].forEach(chartId => {
                        const canvas = document.getElementById(chartId);
                        if (canvas) {
                            // Force canvas to recognize new size
                            canvas.style.width = '100%';
                            canvas.style.height = '100%';
                        }
                    });
                });
            }, 300));

            console.log('✓ Enterprise dashboard initialization complete');
        }

        // Utility function for debouncing resize events
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Enhanced 3D Topology with Three.js
        function initialize3DTopology() {
            const container = document.getElementById('topology3d');
            if (!container) return;

            console.log('Initializing robust 3D topology system...');
            
            // Try Three.js first, with comprehensive error handling
            if (typeof THREE !== 'undefined') {
                try {
                    initRobust3DTopology(container);
                } catch (error) {
                    console.warn('3D initialization failed, using enhanced 2D:', error);
                    initAdvanced2DTopology(container);
                }
            } else {
                console.log('Three.js not yet loaded, starting with 2D and retrying...');
                initAdvanced2DTopology(container);
                
                // Retry with Three.js after a delay
                setTimeout(() => {
                    if (typeof THREE !== 'undefined') {
                        try {
                            console.log('Three.js now available, upgrading to 3D...');
                            container.innerHTML = '';
                            initRobust3DTopology(container);
                        } catch (error) {
                            console.warn('3D upgrade failed:', error);
                        }
                    }
                }, 3000);
            }
        }

        function initRobust3DTopology(container) {
            console.log('Initializing enhanced Three.js 3D topology...');
            
            // Create Three.js scene with advanced settings
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a3a);
            scene.fog = new THREE.Fog(0x1a1a3a, 80, 300);
            
            // Advanced camera with cinematic positioning
            const camera = new THREE.PerspectiveCamera(60, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.set(25, 18, 30);
            camera.lookAt(0, 0, 0);
            
            // Enhanced renderer with advanced settings
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x0a0a1a, 1);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.physicallyCorrectLights = true;
            container.appendChild(renderer.domElement);

            // Advanced lighting system with realistic parameters
            const ambientLight = new THREE.AmbientLight(0x6080ff, 0.6);
            scene.add(ambientLight);

            // Main directional light (sunlight)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3.5);
            directionalLight.position.set(30, 40, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.bias = -0.0001;
            scene.add(directionalLight);

            // Multiple colored accent lights for dramatic effect
            const lights = [
                { color: 0x667eea, position: [-15, 12, 8], intensity: 2.5 },
                { color: 0x58d68d, position: [15, 10, -8], intensity: 2.2 },
                { color: 0xf093fb, position: [0, 15, 15], intensity: 2.0 },
                { color: 0xf7dc6f, position: [-8, 8, -12], intensity: 1.8 }
            ];

            lights.forEach(lightData => {
                const light = new THREE.PointLight(lightData.color, lightData.intensity, 50, 2);
                light.position.set(...lightData.position);
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                scene.add(light);
            });

            // Rim lighting for dramatic silhouettes
            const rimLight = new THREE.DirectionalLight(0x8888ff, 2.0);
            rimLight.position.set(-20, 20, -20);
            scene.add(rimLight);

            // Additional fill lighting for brightness
            const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
            fillLight.position.set(10, -10, 10);
            scene.add(fillLight);

            // Create the main UPS system with enhanced detail
            const upsGroup = new THREE.Group();

            // Main UPS chassis with realistic proportions and materials
            const upsGeometry = new THREE.BoxGeometry(12, 6, 8);
            const upsMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2d3748,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 0.3,
                clearcoatRoughness: 0.1,
                reflectivity: 0.9
            });
            const upsUnit = new THREE.Mesh(upsGeometry, upsMaterial);
            upsUnit.position.set(0, 3, 0);
            upsUnit.castShadow = true;
            upsUnit.receiveShadow = true;
            upsGroup.add(upsUnit);

            // Detailed ventilation grilles
            for (let i = 0; i < 8; i++) {
                const grillGeometry = new THREE.BoxGeometry(0.3, 5, 0.1);
                const grillMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.9,
                    roughness: 0.3
                });
                const grill = new THREE.Mesh(grillGeometry, grillMaterial);
                grill.position.set(-5.5 + i * 1.4, 3, 4.1);
                grill.castShadow = true;
                upsGroup.add(grill);
            }

            // Enhanced control panel with multiple displays
            const panelGeometry = new THREE.BoxGeometry(4, 3, 0.3);
            const panelMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x1a202c,
                emissive: 0x667eea,
                emissiveIntensity: 0.1,
                metalness: 0.7,
                roughness: 0.1
            });
            const controlPanel = new THREE.Mesh(panelGeometry, panelMaterial);
            controlPanel.position.set(-4, 4, 4.2);
            upsGroup.add(controlPanel);

            // Multiple LCD displays on control panel
            for (let i = 0; i < 3; i++) {
                const displayGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.05);
                const displayMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x001122,
                    emissive: 0x0066ff,
                    emissiveIntensity: 0.8
                });
                const display = new THREE.Mesh(displayGeometry, displayMaterial);
                display.position.set(-4.5 + i * 1.3, 4.5, 4.35);
                upsGroup.add(display);
            }

            // Advanced status LEDs with realistic housing
            const ledColors = [0x48bb78, 0x48bb78, 0x4299e1, 0xed8936, 0xf56565, 0x9b59b6];
            
            for (let i = 0; i < 6; i++) {
                // LED housing
                const housingGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 8);
                const housingMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0x2a2a2a,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const housing = new THREE.Mesh(housingGeometry, housingMaterial);
                housing.position.set(-1 + (i % 3) * 0.5, 4.2 + Math.floor(i / 3) * 0.4, 4.3);
                housing.rotation.x = Math.PI / 2;
                upsGroup.add(housing);

                // LED lens with glow effect
                const ledGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                const ledMaterial = new THREE.MeshBasicMaterial({ 
                    color: ledColors[i],
                    emissive: ledColors[i],
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const led = new THREE.Mesh(ledGeometry, ledMaterial);
                led.position.set(-1 + (i % 3) * 0.5, 4.2 + Math.floor(i / 3) * 0.4, 4.35);
                led.userData = { originalIntensity: 0.8, phase: i * Math.PI / 3, color: ledColors[i] };
                upsGroup.add(led);

                // LED point light for realistic illumination
                const ledLight = new THREE.PointLight(ledColors[i], 0.3, 5);
                ledLight.position.copy(led.position);
                led.userData.light = ledLight;
                scene.add(ledLight);
            }

            // Detailed cooling fans with animation
            for (let f = 0; f < 4; f++) {
                const fanGroup = new THREE.Group();
                
                // Fan housing
                const fanHousingGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.3, 8);
                const fanHousingMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const fanHousing = new THREE.Mesh(fanHousingGeometry, fanHousingMaterial);
                fanHousing.rotation.x = Math.PI / 2;
                fanGroup.add(fanHousing);

                // Fan blades
                for (let b = 0; b < 6; b++) {
                    const bladeGeometry = new THREE.BoxGeometry(0.1, 1, 0.05);
                    const bladeMaterial = new THREE.MeshPhysicalMaterial({ 
                        color: 0x333333,
                        metalness: 0.5,
                        roughness: 0.3
                    });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.position.set(Math.cos(b * Math.PI / 3) * 0.5, 0, Math.sin(b * Math.PI / 3) * 0.5);
                    blade.rotation.y = b * Math.PI / 3;
                    fanGroup.add(blade);
                }

                fanGroup.position.set(-4 + f * 2.5, 6.5, 2);
                fanGroup.userData = { fanSpeed: Math.random() * 0.1 + 0.05 };
                upsGroup.add(fanGroup);
            }

            // Enhanced battery bank with individual cell monitoring
            const batteryGroup = new THREE.Group();
            const batteryRackGeometry = new THREE.BoxGeometry(20, 2, 8);
            const batteryRackMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2d3748,
                metalness: 0.8,
                roughness: 0.3
            });
            const batteryRack = new THREE.Mesh(batteryRackGeometry, batteryRackMaterial);
            batteryRack.position.set(0, 1, -12);
            batteryRack.castShadow = true;
            batteryRack.receiveShadow = true;
            batteryGroup.add(batteryRack);

            // Individual battery cells with charge indicators
            for (let i = 0; i < 12; i++) {
                const batteryGeometry = new THREE.CylinderGeometry(0.8, 0.8, 4, 12);
                const chargeLevels = Array.from({length: 12}, () => 0.85 + Math.random() * 0.1);
                const chargeColor = new THREE.Color().setHSL(0.33 * chargeLevels[i], 0.8, 0.5);
                
                const batteryMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: chargeColor,
                    emissive: chargeColor,
                    emissiveIntensity: 0.1,
                    metalness: 0.2,
                    roughness: 0.7,
                    clearcoat: 0.8,
                    clearcoatRoughness: 0.1
                });
                
                const battery = new THREE.Mesh(batteryGeometry, batteryMaterial);
                battery.position.set(-9 + i * 1.5, 3, -12);
                battery.castShadow = true;
                battery.userData = { chargeLevel: chargeLevels[i], originalColor: chargeColor };
                batteryGroup.add(battery);
                
                // Battery terminals with realistic materials
                const terminalGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 8);
                const terminalMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0xffd700,
                    metalness: 1.0,
                    roughness: 0.1,
                    clearcoat: 1.0
                });
                const terminal = new THREE.Mesh(terminalGeometry, terminalMaterial);
                terminal.position.set(-9 + i * 1.5, 5.2, -12);
                batteryGroup.add(terminal);

                // Charge level indicator lights
                const indicatorLight = new THREE.PointLight(chargeColor, 0.5, 3);
                indicatorLight.position.set(-9 + i * 1.5, 5.5, -12);
                battery.userData.indicator = indicatorLight;
                scene.add(indicatorLight);
            }

            // Advanced power distribution panel
            const switchgearGeometry = new THREE.BoxGeometry(6, 10, 3);
            const switchgearMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x4a5568,
                roughness: 0.2,
                metalness: 0.9,
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            });
            const switchgear = new THREE.Mesh(switchgearGeometry, switchgearMaterial);
            switchgear.position.set(18, 5, 0);
            switchgear.castShadow = true;
            switchgear.receiveShadow = true;

            // Circuit breakers and switches
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 4; col++) {
                    const breakerGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.3);
                    const breakerMaterial = new THREE.MeshPhysicalMaterial({ 
                        color: Math.random() > 0.8 ? 0xff4444 : 0x2d2d2d,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const breaker = new THREE.Mesh(breakerGeometry, breakerMaterial);
                    breaker.position.set(16.5 + col * 1, 1 + row * 1.2, 1.6);
                    switchgear.add(breaker);
                }
            }

            // Enterprise server racks with detailed equipment
            const serverGroup = new THREE.Group();
            for (let i = 0; i < 4; i++) {
                const rackGeometry = new THREE.BoxGeometry(3, 12, 4);
                const rackMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0x2d3748,
                    metalness: 0.9,
                    roughness: 0.1,
                    clearcoat: 0.3
                });
                const rack = new THREE.Mesh(rackGeometry, rackMaterial);
                rack.position.set(25, 6, -8 + i * 5);
                rack.castShadow = true;
                rack.receiveShadow = true;
                serverGroup.add(rack);

                // Server units in rack
                for (let u = 0; u < 20; u++) {
                    const serverGeometry = new THREE.BoxGeometry(2.8, 0.5, 3.8);
                    const serverMaterial = new THREE.MeshPhysicalMaterial({ 
                        color: 0x1a1a1a,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    const server = new THREE.Mesh(serverGeometry, serverMaterial);
                    server.position.set(25, 0.5 + u * 0.6, -8 + i * 5);
                    serverGroup.add(server);

                    // Server status lights with realistic behavior
                    for (let l = 0; l < 8; l++) {
                        const lightGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                        const lightColor = Math.random() > 0.2 ? 0x48bb78 : 0x4299e1;
                        const lightMaterial = new THREE.MeshBasicMaterial({ 
                            color: lightColor,
                            emissive: lightColor,
                            emissiveIntensity: 0.8
                        });
                        const light = new THREE.Mesh(lightGeometry, lightMaterial);
                        light.position.set(23.8, 0.5 + u * 0.6, -8.5 + i * 5 + l * 0.3);
                        light.userData = { 
                            blinkPhase: Math.random() * Math.PI * 2,
                            originalIntensity: 0.8,
                            color: lightColor
                        };
                        serverGroup.add(light);
                    }
                }
            }

            // Enhanced cable management with realistic routing
            const cableSystemGroup = new THREE.Group();
            const cableConfigs = [
                { color: 0xff6b6b, points: [[4, 2, 0], [8, 3, 1], [12, 2.5, 0], [16, 3, 0]] },
                { color: 0x4ecdc4, points: [[4, 2.5, -1], [8, 3.5, 0], [12, 3, 1], [16, 3.5, 1]] },
                { color: 0x45b7d1, points: [[4, 3, 1], [8, 4, 1], [12, 3.5, 0], [16, 4, 0]] },
                { color: 0x96ceb4, points: [[4, 1.5, 1], [8, 2.5, 2], [12, 2, 1], [16, 2.5, 1]] },
                { color: 0xffeaa7, points: [[4, 3.5, -1], [8, 4.5, 0], [12, 4, -1], [16, 4.5, -1]] }
            ];
            
            cableConfigs.forEach((config, index) => {
                const points = config.points.map(p => new THREE.Vector3(...p));
                const cableCurve = new THREE.CatmullRomCurve3(points);
                const cableGeometry = new THREE.TubeGeometry(cableCurve, 32, 0.15, 8, false);
                const cableMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: config.color,
                    metalness: 0.1,
                    roughness: 0.8,
                    clearcoat: 0.8,
                    clearcoatRoughness: 0.2
                });
                const cable = new THREE.Mesh(cableGeometry, cableMaterial);
                cable.castShadow = true;
                cableSystemGroup.add(cable);
            });

            // Advanced power flow visualization with volumetric effects
            const powerFlowGroup = new THREE.Group();
            
            // Power flow particles with enhanced physics
            const createParticleSystem = (count, color, path, speed) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    const point = path(t);
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    const c = new THREE.Color(color);
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                    
                    sizes[i] = Math.random() * 0.5 + 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const particles = new THREE.Points(geometry, material);
                particles.userData = { speed, pathFunction: path, count };
                return particles;
            };

            // Input power flow
            const inputPath = (t) => new THREE.Vector3(-20 + t * 25, 3 + Math.sin(t * Math.PI * 4) * 0.5, Math.sin(t * Math.PI * 2) * 0.3);
            const inputParticles = createParticleSystem(40, 0xff6b6b, inputPath, 0.02);
            powerFlowGroup.add(inputParticles);

            // Output power flow
            const outputPath = (t) => new THREE.Vector3(5 + t * 20, 3 + Math.sin(t * Math.PI * 3) * 0.4, Math.cos(t * Math.PI * 2) * 0.4);
            const outputParticles = createParticleSystem(35, 0x48bb78, outputPath, 0.015);
            powerFlowGroup.add(outputParticles);

            // Enhanced floor with technical grid pattern
            const floorGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const floorMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2c3e50,
                transparent: true,
                opacity: 0.2,
                wireframe: true,
                metalness: 0.5,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            floor.receiveShadow = true;

            // Environmental atmosphere with volumetric lighting
            const atmosphereGeometry = new THREE.BufferGeometry();
            const atmosphereCount = 200;
            const atmospherePositions = new Float32Array(atmosphereCount * 3);
            const atmosphereColors = new Float32Array(atmosphereCount * 3);
            
            for (let i = 0; i < atmosphereCount; i++) {
                atmospherePositions[i * 3] = (Math.random() - 0.5) * 80;
                atmospherePositions[i * 3 + 1] = Math.random() * 20;
                atmospherePositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
                
                const intensity = Math.random() * 0.5 + 0.3;
                atmosphereColors[i * 3] = 0.4 * intensity;
                atmosphereColors[i * 3 + 1] = 0.6 * intensity;
                atmosphereColors[i * 3 + 2] = 0.9 * intensity;
            }
            
            atmosphereGeometry.setAttribute('position', new THREE.BufferAttribute(atmospherePositions, 3));
            atmosphereGeometry.setAttribute('color', new THREE.BufferAttribute(atmosphereColors, 3));
            
            const atmosphereMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const atmosphereParticles = new THREE.Points(atmosphereGeometry, atmosphereMaterial);

            // Add all components to scene
            scene.add(upsGroup);
            scene.add(batteryGroup);
            scene.add(switchgear);
            scene.add(serverGroup);
            scene.add(cableSystemGroup);
            scene.add(powerFlowGroup);
            scene.add(floor);
            scene.add(atmosphereParticles);

            // Enhanced animation loop with realistic physics
            let animationTime = 0;
            function animate() {
                try {
                    animationTime += 0.016;

                    // Animate UPS components
                    upsGroup.rotation.y = Math.sin(animationTime * 0.1) * 0.02;

                    // Animate cooling fans
                    upsGroup.children.forEach(child => {
                        if (child.userData.fanSpeed) {
                            child.rotation.z += child.userData.fanSpeed;
                        }
                    });

                    // Animate LED indicators with realistic patterns
                    upsGroup.children.forEach(child => {
                        if (child.userData.originalIntensity !== undefined) {
                            const systemLoad = ENTERPRISE_CONFIG.currentMetrics?.load || 32000;
                            const loadFactor = systemLoad / 32000;
                            const baseIntensity = child.userData.originalIntensity;
                            const intensity = baseIntensity + 
                                             Math.sin(animationTime * (2 + loadFactor) + child.userData.phase) * (0.4 * loadFactor);
                            child.material.emissiveIntensity = Math.max(0.1, intensity);
                            
                            if (child.userData.light) {
                                child.userData.light.intensity = intensity * 0.3;
                            }
                        }
                    });

                    // Animate server status lights with network activity
                    serverGroup.children.forEach(child => {
                        if (child.userData.blinkPhase !== undefined) {
                            const networkActivity = 0.3 + 
                                                   Math.sin(animationTime * 6 + child.userData.blinkPhase) * 0.4 +
                                                   Math.sin(animationTime * 15 + child.userData.blinkPhase * 2) * 0.3;
                            child.material.emissiveIntensity = Math.max(0.1, networkActivity);
                        }
                    });

                    // Animate power flow particles with physics
                    powerFlowGroup.children.forEach(particleSystem => {
                        const positions = particleSystem.geometry.attributes.position.array;
                        const { speed, pathFunction, count } = particleSystem.userData;
                        
                        for (let i = 0; i < count; i++) {
                            let t = (positions[i * 3] + 20) / 45; // Normalize position to 0-1
                            t += speed;
                            
                            if (t > 1) {
                                t = 0;
                            }
                            
                            const point = pathFunction(t);
                            positions[i * 3] = point.x;
                            positions[i * 3 + 1] = point.y;
                            positions[i * 3 + 2] = point.z;
                        }
                        
                        particleSystem.geometry.attributes.position.needsUpdate = true;
                    });

                    // Animate battery charge indicators
                    batteryGroup.children.forEach(child => {
                        if (child.userData.chargeLevel !== undefined) {
                            const chargeVariation = 0.95 + 0.05 * Math.sin(animationTime * 0.5 + child.position.x);
                            const newIntensity = child.userData.chargeLevel * chargeVariation * 0.2;
                            child.material.emissiveIntensity = newIntensity;
                            
                            if (child.userData.indicator) {
                                child.userData.indicator.intensity = newIntensity * 2;
                            }
                        }
                    });

                    // Dynamic camera movement
                    const radius = 35 + Math.sin(animationTime * 0.1) * 5;
                    camera.position.x = radius * Math.cos(animationTime * 0.02);
                    camera.position.z = radius * Math.sin(animationTime * 0.02);
                    camera.position.y = 18 + Math.sin(animationTime * 0.03) * 3;
                    camera.lookAt(0, 3, 0);

                    // Animate atmospheric particles
                    const atmospherePositions = atmosphereParticles.geometry.attributes.position.array;
                    for (let i = 0; i < atmosphereCount; i++) {
                        atmospherePositions[i * 3] += Math.sin(animationTime + i) * 0.02;
                        atmospherePositions[i * 3 + 1] += Math.cos(animationTime * 0.7 + i) * 0.01;
                        atmospherePositions[i * 3 + 2] += Math.sin(animationTime * 0.9 + i) * 0.015;
                        
                        // Boundary wrapping
                        if (Math.abs(atmospherePositions[i * 3]) > 40) atmospherePositions[i * 3] *= -0.9;
                        if (atmospherePositions[i * 3 + 1] > 20) atmospherePositions[i * 3 + 1] = 0;
                        if (Math.abs(atmospherePositions[i * 3 + 2]) > 40) atmospherePositions[i * 3 + 2] *= -0.9;
                    }
                    atmosphereParticles.geometry.attributes.position.needsUpdate = true;

                    // Dynamic lighting based on system performance
                    const performance = (ENTERPRISE_CONFIG.currentMetrics?.efficiency || 87) / 100;
                    lights.forEach((lightData, index) => {
                        const light = scene.children.find(child => 
                            child.isPointLight && 
                            child.color.getHex() === lightData.color
                        );
                        if (light) {
                            light.intensity = lightData.intensity * (0.5 + performance * 0.7);
                        }
                    });

                    renderer.render(scene, camera);
                    
                    if (container.contains(renderer.domElement)) {
                        requestAnimationFrame(animate);
                    }
                } catch (error) {
                    console.error('3D animation error:', error);
                    setTimeout(() => {
                        if (container.contains(renderer.domElement)) {
                            requestAnimationFrame(animate);
                        }
                    }, 1000);
                }
            }

            // Enhanced resize handling
            const handleResize = () => {
                if (container.offsetWidth > 0 && container.offsetHeight > 0) {
                    camera.aspect = container.offsetWidth / container.offsetHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.offsetWidth, container.offsetHeight);
                }
            };

            window.addEventListener('resize', handleResize);
            
            // Start enhanced animation
            animate();
            
            console.log('Enhanced 3D topology successfully initialized with cinematic lighting');
        }

        function initAdvanced2DTopology(container) {
            container.innerHTML = `<canvas id="topology2d" style="width: 100%; height: 100%; border-radius: 20px;"></canvas>`;
            const canvas = document.getElementById('topology2d');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;

            function drawAdvancedTopology() {
                const time = Date.now() * 0.002;
                
                // Clear with gradient background
                const bgGradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
                bgGradient.addColorStop(0, '#1a1a2e');
                bgGradient.addColorStop(1, '#0f0f23');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Grid pattern background
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 25) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 25) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }

                // Main UPS Unit - Much larger and more detailed
                const upsWidth = 180;
                const upsHeight = 100;
                const upsX = centerX - upsWidth/2;
                const upsY = centerY - upsHeight/2;

                // UPS chassis with 3D effect
                const gradient = ctx.createLinearGradient(upsX, upsY, upsX + upsWidth, upsY + upsHeight);
                gradient.addColorStop(0, '#4a5568');
                gradient.addColorStop(0.5, '#2d3748');
                gradient.addColorStop(1, '#1a202c');
                ctx.fillStyle = gradient;
                ctx.fillRect(upsX, upsY, upsWidth, upsHeight);

                // UPS border with animated glow
                const glowIntensity = 0.7 + 0.3 * Math.sin(time * 2);
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#667eea';
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.strokeRect(upsX, upsY, upsWidth, upsHeight);
                ctx.shadowBlur = 0;

                // Control Panel
                ctx.fillStyle = '#2d3748';
                ctx.fillRect(upsX + 15, upsY + 15, 80, 50);
                ctx.strokeStyle = '#4299e1';
                ctx.lineWidth = 2;
                ctx.strokeRect(upsX + 15, upsY + 15, 80, 50);

                // Large Status Display
                ctx.fillStyle = '#1a202c';
                ctx.fillRect(upsX + 20, upsY + 20, 70, 20);
                ctx.fillStyle = '#48bb78';
                ctx.font = 'bold 14px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('SYSTEM ONLINE', upsX + 55, upsY + 35);

                // Status LEDs with realistic behavior
                const ledColors = ['#48bb78', '#48bb78', '#4299e1', '#ed8936', '#f56565'];
                const ledLabels = ['PWR', 'BAT', 'LOAD', 'WARN', 'FAULT'];
                const ledStates = [1, 0.8, 0.6, 0.2, 0.1]; // Different activity levels
                
                for (let i = 0; i < 5; i++) {
                    const x = upsX + 110 + (i % 3) * 25;
                    const y = upsY + 20 + Math.floor(i / 3) * 30;
                    
                    const intensity = ledStates[i] * (0.8 + 0.2 * Math.sin(time * (3 + i)));
                    
                    // LED glow effect
                    ctx.shadowColor = ledColors[i];
                    ctx.shadowBlur = 25 * intensity;
                    ctx.fillStyle = ledColors[i];
                    ctx.globalAlpha = intensity;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;

                    // LED labels
                    ctx.fillStyle = '#e2e8f0';
                    ctx.font = 'bold 8px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(ledLabels[i], x, y + 18);
                }

                // Main UPS Label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Inter';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 5;
                ctx.fillText('ENTERPRISE UPS', centerX, centerY + 15);
                ctx.shadowBlur = 0;

                // Power Rating
                ctx.fillStyle = '#a0aec0';
                ctx.font = '12px Inter';
                ctx.fillText('50kVA / 45kW', centerX, centerY + 35);

                // Battery Bank - More detailed
                const batteryBankY = centerY + 140;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('BATTERY BANK', centerX, batteryBankY - 25);

                for (let i = 0; i < 8; i++) {
                    const battX = centerX - 120 + i * 30;
                    const chargeLevel = 0.75 + 0.25 * Math.sin(time + i * 0.3);

                    // Battery housing
                    ctx.fillStyle = '#2d3748';
                    ctx.fillRect(battX - 10, batteryBankY, 20, 50);
                    
                    // Charge indicator with gradient
                    const chargeGradient = ctx.createLinearGradient(0, batteryBankY + 50, 0, batteryBankY);
                    chargeGradient.addColorStop(0, '#f56565');
                    chargeGradient.addColorStop(0.5, '#ed8936');
                    chargeGradient.addColorStop(1, '#48bb78');
                    ctx.fillStyle = chargeGradient;
                    
                    const chargeHeight = 46 * chargeLevel;
                    ctx.fillRect(battX - 8, batteryBankY + 50 - chargeHeight, 16, chargeHeight);

                    // Battery terminals
                    ctx.fillStyle = '#ecc94b';
                    ctx.fillRect(battX - 4, batteryBankY - 4, 8, 4);

                    // Charge percentage
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${(chargeLevel * 100).toFixed(0)}%`, battX, batteryBankY + 65);
                }

                // Input Power Line with animation
                ctx.strokeStyle = '#f56565';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(30, centerY);
                ctx.lineTo(upsX - 30, centerY);
                ctx.stroke();

                // Power flow particles
                const flowOffset = (time * 150) % 40;
                for (let i = 0; i < 5; i++) {
                    const particleX = 30 + ((flowOffset + i * 8) % (upsX - 60));
                    ctx.fillStyle = '#fbb6ce';
                    ctx.shadowColor = '#f56565';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(particleX, centerY, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Output Power Line
                ctx.strokeStyle = '#48bb78';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(upsX + upsWidth + 30, centerY);
                ctx.lineTo(canvas.width - 30, centerY);
                ctx.stroke();

                // Output flow particles
                for (let i = 0; i < 5; i++) {
                    const particleX = upsX + upsWidth + 30 + ((flowOffset + i * 8) % (canvas.width - upsX - upsWidth - 60));
                    ctx.fillStyle = '#9ae6b4';
                    ctx.shadowColor = '#48bb78';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(particleX, centerY, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Load Equipment (Servers) - More detailed
                for (let i = 0; i < 3; i++) {
                    const serverX = canvas.width - 140;
                    const serverY = centerY - 75 + i * 50;
                    
                    // Server chassis
                    ctx.fillStyle = '#2d3748';
                    ctx.fillRect(serverX, serverY, 80, 30);
                    ctx.strokeStyle = '#4a5568';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(serverX, serverY, 80, 30);
                    
                    // Server front panel
                    ctx.fillStyle = '#1a202c';
                    ctx.fillRect(serverX + 5, serverY + 5, 15, 20);
                    
                    // Server status lights
                    for (let j = 0; j < 6; j++) {
                        const lightX = serverX + 25 + j * 8;
                        const lightY = serverY + 15;
                        const lightColor = Math.random() > 0.3 ? '#48bb78' : '#4299e1';
                        const lightIntensity = 0.6 + 0.4 * Math.sin(time * 4 + i + j);
                        
                        ctx.shadowColor = lightColor;
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = lightColor;
                        ctx.globalAlpha = lightIntensity;
                        ctx.beginPath();
                        ctx.arc(lightX, lightY, 2, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    }

                    // Server label
                    ctx.fillStyle = '#a0aec0';
                    ctx.font = '10px Inter';
                    ctx.textAlign = 'left';
                    ctx.fillText(`SERVER ${i + 1}`, serverX + 5, serverY + 45);
                }

                // Connection Labels
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Inter';
                ctx.textAlign = 'center';
                
                // Input label
                ctx.fillText('GRID INPUT', 80, centerY - 35);
                ctx.fillStyle = '#a0aec0';
                ctx.font = '10px Inter';
                ctx.fillText('480V AC', 80, centerY - 20);
                
                // Output label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Inter';
                ctx.fillText('CRITICAL LOADS', canvas.width - 80, centerY - 35);
                ctx.fillStyle = '#a0aec0';
                ctx.font = '10px Inter';
                ctx.fillText('Protected Equipment', canvas.width - 80, centerY - 20);

                // Real-time metrics overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(15, 15, 220, 160);
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.strokeRect(15, 15, 220, 160);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'left';
                ctx.fillText('REAL-TIME STATUS', 25, 40);

                ctx.font = 'bold 13px Inter';
                const metrics = [
                    `Load: ${document.getElementById('currentLoad')?.textContent || 'N/A'}`,
                    `Efficiency: ${document.getElementById('systemEfficiency')?.textContent || 'N/A'}`,
                    `Battery: ${document.getElementById('batteryHealth')?.textContent || 'N/A'}`,
                    `Temperature: ${document.getElementById('temperature')?.textContent || 'N/A'}`,
                    `Frequency: ${document.getElementById('frequency')?.textContent || 'N/A'}`,
                    `Neural Score: ${document.getElementById('neuralScore')?.textContent || 'N/A'}`,
                    `Status: ${ENTERPRISE_CONFIG.systemRunning ? 'ACTIVE' : 'STANDBY'}`,
                    `AI Mode: ${ENTERPRISE_CONFIG.aiMode ? 'ENABLED' : 'DISABLED'}`
                ];

                metrics.forEach((metric, index) => {
                    ctx.fillStyle = index < 6 ? '#4299e1' : '#48bb78';
                    ctx.fillText(metric, 25, 65 + index * 16);
                });

                // Timestamp
                ctx.fillStyle = '#a0aec0';
                ctx.font = '10px Inter';
                ctx.textAlign = 'right';
                ctx.fillText(`Updated: ${new Date().toLocaleTimeString()}`, canvas.width - 25, canvas.height - 15);

                // Continue animation
                requestAnimationFrame(drawAdvancedTopology);
            }

            // Start immediately
            drawAdvancedTopology();
        }

        // Enhanced Canvas Chart System with Real-time Updates
        function initializeCanvasCharts() {
            console.log('Initializing enhanced canvas-based charts...');
            
            // Ensure we have data first
            if (ENTERPRISE_CONFIG.timeSeriesData.loadData.length === 0) {
                generateRealisticData();
            }
            
            // Initialize all chart canvases with proper sizing
            ['loadChart', 'efficiencyChart', 'harmonicChart', 'neuralChart'].forEach(chartId => {
                const canvas = document.getElementById(chartId);
                if (canvas) {
                    // Set initial canvas styles for better rendering
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.display = 'block';
                    
                    if (chartId === 'neuralChart') {
                        // Neural chart has its own specialized renderer
                        return;
                    }
                    
                    drawAdvancedCanvasChart(canvas, chartId);
                }
            });

            // Start continuous animation loop for all charts
            function animateCanvasCharts() {
                ['loadChart', 'efficiencyChart', 'harmonicChart'].forEach(chartId => {
                    const canvas = document.getElementById(chartId);
                    if (canvas && canvas.offsetWidth > 0 && canvas.offsetHeight > 0) {
                        drawAdvancedCanvasChart(canvas, chartId);
                    }
                });
                
                // Continue animation for smooth real-time updates
                requestAnimationFrame(animateCanvasCharts);
            }
            
            // Start animation with slight delay to ensure DOM is ready
            setTimeout(() => {
                animateCanvasCharts();
            }, 100);
        }

        function drawAdvancedCanvasChart(canvas, chartType) {
            const ctx = canvas.getContext('2d');
            
            // Ensure proper sizing
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;

            // Clear with enhanced gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(15, 15, 35, 0.95)');
            gradient.addColorStop(0.3, 'rgba(26, 26, 46, 0.98)');
            gradient.addColorStop(0.7, 'rgba(20, 20, 40, 0.98)');
            gradient.addColorStop(1, 'rgba(10, 10, 25, 0.95)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            switch (chartType) {
                case 'loadChart':
                    drawRealtimeWaveform(ctx, ENTERPRISE_CONFIG.timeSeriesData.loadData, '#5dade2', 'Load (kW)', width, height);
                    break;
                case 'efficiencyChart':
                    drawRealtimeWaveform(ctx, ENTERPRISE_CONFIG.timeSeriesData.efficiencyData, '#58d68d', 'Efficiency (%)', width, height);
                    break;
                case 'harmonicChart':
                    drawRealtimeBarChart(ctx, width, height);
                    break;
            }
        }

        function drawRealtimeWaveform(ctx, data, color, yLabel, width, height) {
            const padding = 60;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 120;
            const time = Date.now() * 0.001;

            // Ensure we have data
            if (!data || data.length === 0) {
                data = [];
                for (let i = 0; i < 50; i++) {
                    data.push(30000 + Math.sin(i * 0.3 + time) * 5000 + Math.random() * 2000);
                }
            }

            // Calculate bounds with enhanced range
            const minVal = Math.min(...data) * 0.9;
            const maxVal = Math.max(...data) * 1.1;
            const valueRange = maxVal - minVal;

            // Enhanced grid system with better visibility
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            for (let i = 0; i <= 8; i++) {
                const y = padding + 40 + (chartHeight / 8) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // Vertical grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            for (let i = 0; i <= 10; i++) {
                const x = padding + (chartWidth / 10) * i;
                ctx.beginPath();
                ctx.moveTo(x, padding + 40);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Enhanced waveform with maximum visibility
            if (data.length > 1) {
                // Outer glow effect
                ctx.shadowColor = color;
                ctx.shadowBlur = 30;
                ctx.strokeStyle = color;
                ctx.lineWidth = 8;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();

                data.forEach((value, index) => {
                    const x = padding + (index / (data.length - 1)) * chartWidth;
                    const y = padding + 40 + chartHeight - ((value - minVal) / valueRange) * chartHeight;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                // Inner bright line
                ctx.shadowBlur = 20;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.globalAlpha = 1;
                ctx.beginPath();

                data.forEach((value, index) => {
                    const x = padding + (index / (data.length - 1)) * chartWidth;
                    const y = padding + 40 + chartHeight - ((value - minVal) / valueRange) * chartHeight;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Core waveform
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();

                data.forEach((value, index) => {
                    const x = padding + (index / (data.length - 1)) * chartWidth;
                    const y = padding + 40 + chartHeight - ((value - minVal) / valueRange) * chartHeight;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                // Enhanced fill area
                ctx.globalAlpha = 0.3;
                const fillGradient = ctx.createLinearGradient(0, padding + 40, 0, height - padding);
                fillGradient.addColorStop(0, color);
                fillGradient.addColorStop(1, color + '00');
                ctx.fillStyle = fillGradient;
                ctx.beginPath();
                data.forEach((value, index) => {
                    const x = padding + (index / (data.length - 1)) * chartWidth;
                    const y = padding + 40 + chartHeight - ((value - minVal) / valueRange) * chartHeight;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.lineTo(width - padding, height - padding);
                ctx.lineTo(padding, height - padding);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;

                // Data points with enhanced visibility
                data.forEach((value, index) => {
                    if (index % 3 === 0) { // Show every 3rd point to avoid clutter
                        const x = padding + (index / (data.length - 1)) * chartWidth;
                        const y = padding + 40 + chartHeight - ((value - minVal) / valueRange) * chartHeight;
                        
                        const pulseSize = 6 + Math.sin(time * 3 + index * 0.2) * 2;
                        
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(x, y, pulseSize, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, pulseSize * 0.5, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
            }

            // Current value display - much larger and more prominent
            const currentValue = data[data.length - 1] || 0;
            
            ctx.font = 'bold 28px Inter';
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.shadowColor = color;
            ctx.shadowBlur = 15;
            
            const valueBoxWidth = 200;
            const valueBoxHeight = 60;
            const valueBoxX = width - valueBoxWidth - 30;
            const valueBoxY = 30;
            
            // Value box background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(valueBoxX, valueBoxY, valueBoxWidth, valueBoxHeight);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.strokeRect(valueBoxX, valueBoxY, valueBoxWidth, valueBoxHeight);
            
            // Value text
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            
            let displayText = '';
            let unitText = '';
            if (yLabel.includes('Load')) {
                displayText = `${(currentValue/1000).toFixed(1)}`;
                unitText = 'kW';
            } else if (yLabel.includes('Efficiency')) {
                displayText = `${currentValue.toFixed(1)}`;
                unitText = '%';
            }
            
            ctx.strokeText(displayText, valueBoxX + valueBoxWidth/2, valueBoxY + 35);
            ctx.fillText(displayText, valueBoxX + valueBoxWidth/2, valueBoxY + 35);
            
            ctx.font = 'bold 16px Inter';
            ctx.fillStyle = color;
            ctx.fillText(unitText, valueBoxX + valueBoxWidth/2, valueBoxY + 52);
            ctx.shadowBlur = 0;

            // Y-axis labels with better visibility
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Inter';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 8; i++) {
                const value = minVal + (valueRange * i / 8);
                const y = height - padding - (chartHeight / 8) * i;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(padding - 65, y - 12, 60, 24);
                
                let label = '';
                if (yLabel.includes('Load')) {
                    label = `${(value/1000).toFixed(1)}k`;
                } else {
                    label = `${value.toFixed(1)}`;
                }
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(label, padding - 35, y + 4);
            }
        }

        function drawRealtimeBarChart(ctx, width, height) {
            const padding = 60;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 120;
            const time = Date.now() * 0.001;

            // Dynamic harmonic data with realistic values
            const harmonicData = [
                100, // Fundamental - always 100%
                4.2 + Math.sin(time * 0.5) * 0.8,
                3.1 + Math.sin(time * 0.3) * 0.6,
                2.8 + Math.sin(time * 0.7) * 0.4,
                1.9 + Math.sin(time * 0.4) * 0.3,
                1.2 + Math.sin(time * 0.6) * 0.2,
                0.8 + Math.sin(time * 0.2) * 0.1
            ];

            const labels = ['Fund', '3rd', '5th', '7th', '9th', '11th', '13th'];
            const colors = ['#58d68d', '#f093fb', '#5dade2', '#f7dc6f', '#bb8fce', '#ec7063', '#85c1e9'];

            const maxVal = 100; // Set to 100 for percentage scale
            const barWidth = (chartWidth / harmonicData.length) * 0.8;
            const barSpacing = (chartWidth / harmonicData.length) * 0.2;

            // Enhanced grid system
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            for (let i = 0; i <= 5; i++) {
                const y = padding + 40 + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Draw enhanced animated bars
            harmonicData.forEach((value, index) => {
                const x = padding + barSpacing / 2 + index * (barWidth + barSpacing);
                const barHeight = (value / maxVal) * chartHeight;
                const y = height - padding - barHeight;

                // Animated bar height with pulsing effect
                const pulseEffect = 0.95 + 0.05 * Math.sin(time * 3 + index * 0.5);
                const animatedHeight = barHeight * pulseEffect;
                const animatedY = height - padding - animatedHeight;

                // Enhanced gradient fill for bars
                const gradient = ctx.createLinearGradient(0, animatedY, 0, height - padding);
                gradient.addColorStop(0, colors[index]);
                gradient.addColorStop(0.6, colors[index] + 'AA');
                gradient.addColorStop(1, colors[index] + '33');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, animatedY, barWidth, animatedHeight);

                // Bar border with enhanced glow
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 3;
                ctx.shadowColor = colors[index];
                ctx.shadowBlur = 15;
                ctx.strokeRect(x, animatedY, barWidth, animatedHeight);
                
                // Inner highlight
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 0;
                ctx.strokeRect(x + 2, animatedY + 2, barWidth - 4, animatedHeight - 4);

                // Value labels with enhanced visibility
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(x + barWidth/2 - 25, animatedY - 25, 50, 20);
                
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 2;
                ctx.strokeRect(x + barWidth/2 - 25, animatedY - 25, 50, 20);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(value.toFixed(1) + '%', x + barWidth / 2, animatedY - 10);

                // X-axis labels with enhanced styling
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(x + barWidth/2 - 20, height - padding + 5, 40, 20);
                
                ctx.strokeStyle = colors[index];
                ctx.lineWidth = 1;
                ctx.strokeRect(x + barWidth/2 - 20, height - padding + 5, 40, 20);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px Inter';
                ctx.fillText(labels[index], x + barWidth / 2, height - padding + 18);
            });

            // Enhanced title
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(padding, 20, 300, 30);
            ctx.strokeStyle = '#58d68d';
            ctx.lineWidth = 2;
            ctx.strokeRect(padding, 20, 300, 30);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('Harmonic Distortion Analysis (%)', padding + 10, 40);
            
            // Current time with enhanced styling
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(width - 200, 20, 170, 30);
            ctx.strokeStyle = '#5dade2';
            ctx.lineWidth = 2;
            ctx.strokeRect(width - 200, 20, 170, 30);
            
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px Inter';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`${new Date().toLocaleTimeString()}`, width - 115, 40);

            // Y-axis scale with better visibility
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = (i / 5) * 100;
                const y = height - padding - (chartHeight / 5) * i;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(padding - 45, y - 10, 40, 20);
                
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 1;
                ctx.strokeRect(padding - 45, y - 10, 40, 20);
                
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText(`${value.toFixed(0)}%`, padding - 25, y + 3);
            }
        }

        // Neural Network Canvas Chart with proper sizing
        function initializeNeuralChart() {
            const neuralCanvas = document.getElementById('neuralChart');
            if (neuralCanvas) {
                function drawNeuralNetwork() {
                    const ctx = neuralCanvas.getContext('2d');
                    
                    // Ensure proper sizing
                    const rect = neuralCanvas.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    neuralCanvas.width = rect.width * dpr;
                    neuralCanvas.height = rect.height * dpr;
                    ctx.scale(dpr, dpr);
                    
                    const width = rect.width;
                    const height = rect.height;
                    
                    // Clear with enhanced gradient background
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, 'rgba(15, 15, 35, 0.95)');
                    gradient.addColorStop(0.5, 'rgba(26, 26, 46, 0.98)');
                    gradient.addColorStop(1, 'rgba(10, 10, 25, 0.95)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                    
                    const layers = [8, 16, 12, 8, 1];
                    const layerWidth = width / (layers.length + 1);
                    const time = Date.now() * 0.002;
                    
                    // Enhanced background grid
                    ctx.strokeStyle = 'rgba(102, 126, 234, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    for (let i = 0; i < width; i += 30) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, height);
                        ctx.stroke();
                    }
                    for (let i = 0; i < height; i += 30) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(width, i);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                    
                    // Draw enhanced connections with data flow animation
                    for (let l = 0; l < layers.length - 1; l++) {
                        const currentLayerX = (l + 1) * layerWidth;
                        const nextLayerX = (l + 2) * layerWidth;
                        
                        for (let i = 0; i < Math.min(layers[l], 12); i++) {
                            for (let j = 0; j < Math.min(layers[l + 1], 12); j++) {
                                const y1 = (height / (Math.min(layers[l], 12) + 1)) * (i + 1);
                                const y2 = (height / (Math.min(layers[l + 1], 12) + 1)) * (j + 1);
                                
                                const weight = 0.3 + 0.7 * Math.sin(time * 2 + l + i + j);
                                const opacity = 0.1 + 0.6 * weight;
                                
                                // Connection line with gradient
                                const connectionGradient = ctx.createLinearGradient(currentLayerX, y1, nextLayerX, y2);
                                connectionGradient.addColorStop(0, `rgba(93, 173, 226, ${opacity})`);
                                connectionGradient.addColorStop(0.5, `rgba(240, 147, 251, ${opacity * 0.8})`);
                                connectionGradient.addColorStop(1, `rgba(88, 214, 141, ${opacity * 0.6})`);
                                
                                ctx.strokeStyle = connectionGradient;
                                ctx.lineWidth = 1 + weight * 2;
                                
                                ctx.beginPath();
                                ctx.moveTo(currentLayerX, y1);
                                ctx.lineTo(nextLayerX, y2);
                                ctx.stroke();
                                
                                // Data flow particles along connections
                                if (weight > 0.7) {
                                    const flowT = (time * 3 + l + i) % 1;
                                    const flowX = currentLayerX + (nextLayerX - currentLayerX) * flowT;
                                    const flowY = y1 + (y2 - y1) * flowT;
                                    
                                    ctx.fillStyle = `rgba(255, 255, 255, ${weight})`;
                                    ctx.shadowColor = '#ffffff';
                                    ctx.shadowBlur = 8;
                                    ctx.beginPath();
                                    ctx.arc(flowX, flowY, 2, 0, 2 * Math.PI);
                                    ctx.fill();
                                    ctx.shadowBlur = 0;
                                }
                            }
                        }
                    }
                    
                    // Draw enhanced neurons with realistic activation
                    for (let l = 0; l < layers.length; l++) {
                        const x = (l + 1) * layerWidth;
                        const neuronsToShow = Math.min(layers[l], 12);
                        
                        for (let i = 0; i < neuronsToShow; i++) {
                            const y = (height / (neuronsToShow + 1)) * (i + 1);
                            
                            const activation = 0.2 + 0.8 * Math.sin(time * 3 + l * 0.8 + i * 0.4);
                            const radius = 8 + activation * 4;
                            
                            // Neuron glow effect
                            const glowRadius = radius + 15;
                            const glowGradient = ctx.createRadialGradient(x, y, radius, x, y, glowRadius);
                            const hue = 200 + activation * 60;
                            
                            glowGradient.addColorStop(0, `hsla(${hue}, 70%, 60%, ${activation * 0.8})`);
                            glowGradient.addColorStop(0.7, `hsla(${hue}, 70%, 50%, ${activation * 0.3})`);
                            glowGradient.addColorStop(1, `hsla(${hue}, 70%, 40%, 0)`);
                            
                            ctx.fillStyle = glowGradient;
                            ctx.beginPath();
                            ctx.arc(x, y, glowRadius, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            // Main neuron body with gradient
                            const neuronGradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
                            neuronGradient.addColorStop(0, `hsl(${hue}, 70%, ${60 + activation * 20}%)`);
                            neuronGradient.addColorStop(0.7, `hsl(${hue}, 70%, ${40 + activation * 30}%)`);
                            neuronGradient.addColorStop(1, `hsl(${hue}, 70%, ${20 + activation * 20}%)`);
                            
                            ctx.fillStyle = neuronGradient;
                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            // Neuron border
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.shadowColor = `hsl(${hue}, 70%, 60%)`;
                            ctx.shadowBlur = 5;
                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, 2 * Math.PI);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                            
                            // Activation level indicator
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.font = 'bold 8px Inter';
                            ctx.textAlign = 'center';
                            ctx.fillText((activation * 100).toFixed(0), x, y + 2);
                        }
                    }
                    
                    // Enhanced layer labels with backgrounds
                    const labels = ['INPUT', 'LSTM', 'DENSE', 'OUTPUT', 'PRED'];
                    ctx.font = 'bold 14px Inter';
                    ctx.textAlign = 'center';
                    
                    for (let l = 0; l < layers.length; l++) {
                        const x = (l + 1) * layerWidth;
                        
                        // Label background
                        const labelWidth = 80;
                        const labelHeight = 25;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(x - labelWidth/2, height - 35, labelWidth, labelHeight);
                        
                        ctx.strokeStyle = '#667eea';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x - labelWidth/2, height - 35, labelWidth, labelHeight);
                        
                        // Label text
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(labels[l], x, height - 18);
                        
                        // Node count
                        ctx.font = 'bold 10px Inter';
                        ctx.fillStyle = '#bdc3c7';
                        ctx.fillText(`(${layers[l]})`, x, height - 5);
                        ctx.font = 'bold 14px Inter';
                    }
                    
                    // Performance metrics overlay
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.fillRect(20, 20, 200, 100);
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(20, 20, 200, 100);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 14px Inter';
                    ctx.textAlign = 'left';
                    ctx.fillText('NEURAL METRICS', 30, 40);
                    
                    ctx.font = 'bold 12px Inter';
                    const metrics = [
                        `Accuracy: ${(89.4 + Math.sin(time) * 3).toFixed(1)}%`,
                        `Loss: ${(0.045 + Math.sin(time * 0.7) * 0.01).toFixed(3)}`,
                        `Epoch: ${Math.floor(time * 10) % 1000}`,
                        `LR: ${(0.001 * Math.exp(-time * 0.1)).toExponential(2)}`,
                        `Batch: ${Math.floor(time * 5) % 64 + 1}/64`
                    ];
                    
                    metrics.forEach((metric, index) => {
                        ctx.fillStyle = index % 2 === 0 ? '#4299e1' : '#48bb78';
                        ctx.fillText(metric, 30, 60 + index * 12);
                    });
                }

                function animateNeuralNetwork() {
                    drawNeuralNetwork();
                    requestAnimationFrame(animateNeuralNetwork);
                }

                // Start immediately
                animateNeuralNetwork();
            }
        }

        // Real-time Simulation
        function startRealTimeSimulation() {
            ENTERPRISE_CONFIG.systemRunning = true;
            
            setInterval(() => {
                if (ENTERPRISE_CONFIG.systemRunning) {
                    updateRealTimeData();
                    updateChartsData();
                    updateFinancialMetrics();
                    updateAIMetrics();
                }
            }, 3000);
        }

        function updateRealTimeData() {
            const now = new Date();
            const hours = now.getHours();
            
            // Advanced load calculation with realistic electrical parameters
            const baseLoad = 32000;
            const timeVariation = Math.sin((hours / 24) * 2 * Math.PI) * baseLoad * 0.25;
            const businessHours = (hours >= 8 && hours <= 18) ? 1.2 : 0.8;
            const randomVariation = (Math.random() - 0.5) * baseLoad * 0.12;
            const currentLoad = Math.max(18000, baseLoad * businessHours + timeVariation + randomVariation);

            // Realistic efficiency with AI boost
            const baseEfficiency = 85;
            const aiBoost = ENTERPRISE_CONFIG.aiMode ? 4.5 : 0;
            const loadEffect = Math.abs(currentLoad / baseLoad - 0.8) * -6;
            const randomNoise = (Math.random() - 0.5) * 2;
            const efficiency = Math.max(78, Math.min(94, baseEfficiency + aiBoost + loadEffect + randomNoise));

            // Technical electrical parameters
            const powerFactor = 0.92 + (Math.random() * 0.06) + (efficiency > 90 ? 0.02 : 0);
            const frequency = 49.95 + (Math.random() * 0.1) + (Math.sin(ENTERPRISE_CONFIG.currentTime * 0.01) * 0.05);
            const thdInput = 2.8 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.05) * 0.8 + Math.random() * 0.6;
            const thdOutput = 1.2 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.03) * 0.4 + Math.random() * 0.3;
            const temperature = 38 + (currentLoad / baseLoad) * 12 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.02) * 3;
            const dcVoltage = 380 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.08) * 8 + (Math.random() - 0.5) * 6;
            const inputVoltage = 400 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.06) * 6 + (Math.random() - 0.5) * 4;
            const outputVoltage = 400 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.04) * 2 + (Math.random() - 0.5) * 2;
            const backupTime = Math.max(15, 60 - (currentLoad / baseLoad - 0.5) * 40 + (Math.random() - 0.5) * 10);
            const peakDemand = Math.max(currentLoad/1000, 45 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.1) * 15 + Math.random() * 8);

            // Advanced electrical and power electronics parameters
            const igbtTemp = temperature + 25 + (currentLoad / baseLoad) * 15;
            const transformerTemp = temperature + 8 + (currentLoad / baseLoad) * 8;
            const capacitorESR = 0.04 + (temperature - 25) * 0.0002 + Math.random() * 0.01;
            const switchingFreq = 16000 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.02) * 500 + (Math.random() - 0.5) * 200;
            const deadTime = 2.5 + (igbtTemp - 65) * 0.01 + Math.random() * 0.3;
            const rippleCurrent = 3.5 + (currentLoad / baseLoad) * 2.5 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.08) * 0.8;
            const dvdtRate = 1200 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.06) * 100 + (Math.random() - 0.5) * 50;
            const faultCount = Math.max(0, Math.floor(Math.random() * 0.1)); // Very low fault rate

            // Battery metrics
            const batteryHealth = Math.max(85, 91.2 - (ENTERPRISE_CONFIG.totalRuntime * 0.0001) + (Math.random() - 0.5) * 1);
            const neuralScore = 78 + (efficiency - 78) * 0.8 + (Math.random() - 0.5) * 3;

            // Update all displays with enhanced technical precision
            document.getElementById('currentLoad').textContent = `${currentLoad.toLocaleString()} VA`;
            document.getElementById('systemEfficiency').textContent = `${efficiency.toFixed(1)}%`;
            document.getElementById('powerFactor').textContent = powerFactor.toFixed(3);
            document.getElementById('frequency').textContent = `${frequency.toFixed(2)} Hz`;
            document.getElementById('thdInput').textContent = `${thdInput.toFixed(2)}%`;
            document.getElementById('thdOutput').textContent = `${thdOutput.toFixed(2)}%`;
            document.getElementById('temperature').textContent = `${temperature.toFixed(1)}°C`;
            document.getElementById('dcVoltage').textContent = `${dcVoltage.toFixed(0)} VDC`;
            document.getElementById('inputVoltage').textContent = `${inputVoltage.toFixed(0)} VAC`;
            document.getElementById('outputVoltage').textContent = `${outputVoltage.toFixed(0)} VAC`;
            document.getElementById('backupTime').textContent = `${backupTime.toFixed(1)} min`;
            document.getElementById('peakDemand').textContent = `${peakDemand.toFixed(1)} kW`;
            document.getElementById('batteryHealth').textContent = `${batteryHealth.toFixed(1)}%`;
            document.getElementById('neuralScore').textContent = neuralScore.toFixed(1);

            // Update all advanced technical displays
            document.getElementById('igbtTemp').textContent = `${igbtTemp.toFixed(1)}°C`;
            document.getElementById('transformerTemp').textContent = `${transformerTemp.toFixed(1)}°C`;
            document.getElementById('capacitorESR').textContent = `${capacitorESR.toFixed(3)} Ω`;
            document.getElementById('switchingFreq').textContent = `${(switchingFreq/1000).toFixed(1)} kHz`;
            document.getElementById('deadTime').textContent = `${deadTime.toFixed(1)} μs`;
            document.getElementById('rippleCurrent').textContent = `${rippleCurrent.toFixed(1)} Arms`;
            document.getElementById('dvdtRate').textContent = `${dvdtRate.toFixed(0)} V/μs`;
            document.getElementById('faultCount').textContent = `${faultCount}`;

            // Update time series data with enhanced parameters
            ENTERPRISE_CONFIG.timeSeriesData.timestamps.push(now);
            ENTERPRISE_CONFIG.timeSeriesData.loadData.push(currentLoad);
            ENTERPRISE_CONFIG.timeSeriesData.efficiencyData.push(efficiency);
            ENTERPRISE_CONFIG.timeSeriesData.harmonicData.push(thdInput);

            // Keep only last 50 points for performance
            if (ENTERPRISE_CONFIG.timeSeriesData.timestamps.length > 50) {
                ENTERPRISE_CONFIG.timeSeriesData.timestamps.shift();
                ENTERPRISE_CONFIG.timeSeriesData.loadData.shift();
                ENTERPRISE_CONFIG.timeSeriesData.efficiencyData.shift();
                ENTERPRISE_CONFIG.timeSeriesData.harmonicData.shift();
            }

            ENTERPRISE_CONFIG.currentTime += 1;
            ENTERPRISE_CONFIG.totalRuntime += 3;

            // Store advanced technical parameters
            ENTERPRISE_CONFIG.currentMetrics = {
                load: currentLoad,
                efficiency: efficiency,
                powerFactor: powerFactor,
                frequency: frequency,
                temperature: temperature,
                dcVoltage: dcVoltage,
                inputVoltage: inputVoltage,
                outputVoltage: outputVoltage,
                thdInput: thdInput,
                thdOutput: thdOutput,
                backupTime: backupTime,
                peakDemand: peakDemand,
                batteryHealth: batteryHealth,
                neuralScore: neuralScore,
                igbtTemp: igbtTemp,
                transformerTemp: transformerTemp,
                capacitorESR: capacitorESR,
                switchingFreq: switchingFreq,
                deadTime: deadTime,
                rippleCurrent: rippleCurrent,
                dvdtRate: dvdtRate,
                faultCount: faultCount
            };
        }

        function updateChartsData() {
            // Charts are now canvas-based and update automatically
        }

        function updateFinancialMetrics() {
            const currentLoad = ENTERPRISE_CONFIG.timeSeriesData.loadData[ENTERPRISE_CONFIG.timeSeriesData.loadData.length - 1] || 32000;
            const realPowerKW = (currentLoad * 0.85) / 1000;
            
            const dailyEnergy = realPowerKW * 24;
            const dailyCost = dailyEnergy * ENTERPRISE_CONFIG.electricityRate;
            const monthlyCost = dailyCost * 30;
            const annualCost = dailyCost * 365;
            const optimizationSavings = annualCost * (ENTERPRISE_CONFIG.aiMode ? 0.13 : 0.08);
            const roiYears = 150000 / optimizationSavings;
            const carbonFootprint = dailyEnergy * 0.9 * 30;

            const energySaved = Math.min(500, 234 + (ENTERPRISE_CONFIG.totalRuntime * 0.01));
            const costSavings = energySaved * ENTERPRISE_CONFIG.electricityRate;
            
            document.getElementById('energySaved').textContent = `${energySaved.toFixed(0)} kWh`;
            document.getElementById('costSavings').textContent = `R${costSavings.toLocaleString()}`;
            document.getElementById('dailyCost').textContent = `R${dailyCost.toFixed(2)}`;
            document.getElementById('monthlyCost').textContent = `R${monthlyCost.toLocaleString()}`;
            document.getElementById('annualCost').textContent = `R${annualCost.toLocaleString()}`;
            document.getElementById('potentialSavings').textContent = `R${optimizationSavings.toLocaleString()}`;
            document.getElementById('roiPeriod').textContent = `${roiYears.toFixed(1)} years`;
            document.getElementById('carbonFootprint').textContent = `${carbonFootprint.toFixed(1)} kg CO₂`;
        }

        function updateAIMetrics() {
            const modelAccuracy = 89.4 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.02) * 3.0;
            const predictionConfidence = 84.8 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.03) * 4.0;
            const trainingSamples = 1.2 + (ENTERPRISE_CONFIG.totalRuntime / 50000);
            const processingSpeed = 543 + Math.sin(ENTERPRISE_CONFIG.currentTime * 0.05) * 120;
            
            document.getElementById('modelAccuracy').textContent = `${modelAccuracy.toFixed(1)}%`;
            document.getElementById('predictionConfidence').textContent = `${predictionConfidence.toFixed(1)}%`;
            document.getElementById('trainingSamples').textContent = `${trainingSamples.toFixed(1)}M`;
            document.getElementById('processingSpeed').textContent = `${processingSpeed.toFixed(0)} Hz`;
        }

        // Control Functions
        function startSystem() {
            ENTERPRISE_CONFIG.systemRunning = true;
            const statusEl = document.getElementById('systemStatus');
            if (statusEl) {
                statusEl.innerHTML = '<div class="status-indicator"></div>SYSTEM STATUS: ACTIVE - Enterprise AI Engine Running';
                statusEl.style.color = 'var(--accent-green)';
            }
            showNotification('Enterprise System Activated - Full AI Optimization Online', 'success');
        }

        function stopSystem() {
            ENTERPRISE_CONFIG.systemRunning = false;
            const statusEl = document.getElementById('systemStatus');
            if (statusEl) {
                statusEl.innerHTML = '<div class="status-indicator" style="background: var(--danger); box-shadow: 0 0 25px var(--danger);"></div>SYSTEM STATUS: EMERGENCY STOP - All Operations Halted';
                statusEl.style.color = 'var(--danger)';
            }
            showNotification('Emergency Stop Activated - System Safely Shutdown', 'warning');
        }

        function toggleAIMode() {
            ENTERPRISE_CONFIG.aiMode = !ENTERPRISE_CONFIG.aiMode;
            const btn = event.target;
            
            if (btn) {
                if (ENTERPRISE_CONFIG.aiMode) {
                    btn.textContent = 'AI Optimization ON';
                    btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71, #58d68d)';
                    showNotification('Neural Network Optimization Activated - Efficiency Boost Enabled', 'success');
                } else {
                    btn.textContent = 'AI Optimization';
                    btn.style.background = 'linear-gradient(135deg, #9b59b6, #8e44ad, #bb8fce)';
                    showNotification('AI Optimization Deactivated - Manual Mode Active', 'info');
                }
            }
        }

        function runSimulation() {
            showNotification('Monte Carlo Simulation Started - 10,000 Iterations', 'info');
            
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 12 + 3;
                
                if (progress >= 100) {
                    clearInterval(interval);
                    showNotification('Simulation Complete - Efficiency Improvement: 8.7%, Cost Savings: R47,231', 'success');
                }
            }, 250);
        }

        function performAnalysis() {
            showNotification('Deep Learning Analysis Initiated - Processing Historical Data', 'info');
            
            setTimeout(() => {
                const efficiency = (Math.random() * 3 + 5).toFixed(1);
                const optimization = (Math.random() * 15 + 8).toFixed(1);
                showNotification(`Analysis Complete: ${efficiency}% efficiency improvement, ${optimization}% cost optimization potential`, 'success');
            }, 3000);
        }

        function exportReport() {
            try {
                const reportData = {
                    timestamp: new Date().toISOString(),
                    systemStatus: ENTERPRISE_CONFIG.systemRunning ? 'Active' : 'Stopped',
                    aiOptimization: ENTERPRISE_CONFIG.aiMode,
                    currentMetrics: {
                        load: document.getElementById('currentLoad')?.textContent || 'N/A',
                        efficiency: document.getElementById('systemEfficiency')?.textContent || 'N/A',
                        batteryHealth: document.getElementById('batteryHealth')?.textContent || 'N/A',
                        uptime: document.getElementById('systemUptime')?.textContent || 'N/A'
                    }
                };
                
                const reportText = `
ENTERPRISE UPS MANAGEMENT SYSTEM - REPORT
Generated: ${new Date().toLocaleString()}
================================================================

SYSTEM STATUS: ${reportData.systemStatus}
AI OPTIMIZATION: ${reportData.aiOptimization ? 'ACTIVE' : 'STANDBY'}

PERFORMANCE METRICS:
- Current Load: ${reportData.currentMetrics.load}
- System Efficiency: ${reportData.currentMetrics.efficiency}  
- Battery Health: ${reportData.currentMetrics.batteryHealth}
- System Uptime: ${reportData.currentMetrics.uptime}

================================================================
Report Generated by Enterprise UPS Management System v5.0.0
                `;
                
                const blob = new Blob([reportText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `UPS_Report_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showNotification('Enterprise Report Generated Successfully', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Report Export Failed', 'error');
            }
        }

        // Notification System
        function showNotification(message, type = 'success') {
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="font-weight: 600;">${message}</div>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: none; border: none; color: white; cursor: pointer; font-size: 22px; margin-left: 25px; opacity: 0.8;">×</button>
                </div>
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideInRight 0.4s ease-out reverse';
                    setTimeout(() => notification.remove(), 400);
                }
            }, 6000);
        }
    </script>
</body>
</html>